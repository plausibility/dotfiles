#!/usr/bin/env python3
# -*- encoding: utf-8 -*-
# vim: ts=4 shiftwidth=4 expandtab
# Part of the "sysrq dotfiles experience". Available at:
#    sysrq <chris@gibsonsec.org> https://github.com/sysr-q/dotfiles
#
# This is free and unencumbered software released into the public domain.
#
# Anyone is free to copy, modify, publish, use, compile, sell, or
# distribute this software, either in source code form or as a compiled
# binary, for any purpose, commercial or non-commercial, and by any
# means.
#
# In jurisdictions that recognize copyright laws, the author or authors
# of this software dedicate any and all copyright interest in the
# software to the public domain. We make this dedication for the benefit
# of the public at large and to the detriment of our heirs and
# successors. We intend this dedication to be an overt act of
# relinquishment in perpetuity of all present and future rights to this
# software under copyright law.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.
#
# For more information, please refer to <http://unlicense.org>
from __future__ import print_function

from enum import Enum
import argparse
import os
import sys

try:
    import sh as real_sh
except ImportError:
    print("Install `sh` (pip install sh) for my sanity and yours.")
    sys.exit(1)


class Prefixes(Enum):
    ERROR = " \033[0;31m✖\033[0m"
    SUCCESS = " \033[0;32m✔\033[0m"
    INFO = " \033[0;34m➜\033[0m"
    DEBUG = " \033[0;34m?\033[0m"
    HEADER = "\033[1m{}\033[0m"


class PlainPrefixes(Enum):
    ERROR = "[!]"
    SUCCESS = "[+]"
    INFO = "[ ]"
    DEBUG = "[?]"
    HEADER = "-> {}"


def error(*args, **kwargs):
    print(Prefixes.ERROR.value, *args, **kwargs)


def error_r():
    print("\r" + Prefixes.ERROR.value)


def success(*args, **kwargs):
    print(Prefixes.SUCCESS.value, *args, **kwargs)


def success_r():
    print("\r" + Prefixes.SUCCESS.value)


def info(*args, **kwargs):
    kwargs.setdefault("nr", False)
    kwargs.setdefault("end", "" if kwargs.pop("nr") else None)
    print(Prefixes.INFO.value, *args, **kwargs)
    sys.stdout.flush()


def debug(*args, **kwargs):
    print(Prefixes.DEBUG.value, *args, **kwargs)


def header(*args, **kwargs):
    kwargs.setdefault("nr", False)
    kwargs.setdefault("end", "" if kwargs.pop("nr") else None)
    print(Prefixes.HEADER.value.format(" ".join(args)), **kwargs)
    sys.stdout.flush()


# # # # # # # # # #


def sh(args, *pargs, _always=False, **kwargs):
    # Variably either actually call a command or only print it, depending on
    # the safety of the command (_always) and mode of dotfiles update.
    pargs = list(pargs)
    if args.pretend and not _always:
        print(" ".join(pargs))
        return ""
    command = real_sh.Command(pargs.pop(0))
    return command(*pargs, **kwargs)


def exists(path):
    try:
        os.stat(path)
    except OSError:
        return False
    return True


def find(args, path, t=None, mindepth=1, maxdepth=1):
    if t is not None:
        x = ("-type", t)
    else:
        x = ()

    for f in sh(
        args,
        "find",
        path,
        "-mindepth",
        mindepth,
        "-maxdepth",
        maxdepth,
        "-not",
        "-iwholename",
        "*.git*",
        *x,
        _always=True
    ):
        yield os.path.basename(f.rstrip())


# # # # # # # # # #


def action(f):
    # Globals are unnecessary when functions exist.
    if not hasattr(action, "list"):
        action.list = set()
    action.list.add(f)
    return f


@action
def test_print(args):
    header("This is a test of header()")
    error("This is a test of error()")
    success("This is a test of success()")
    info("This is a test of info()")
    debug("This is a test of debug()")


@action
def update(args):
    if not exists(args.dotfiles):
        info("Cloning dotfiles repository... ", nr=True)
        try:
            sh(
                args,
                "git",
                "clone",
                "--recursive",
                "--branch",
                args.branch,
                args.git_url,
                args.dotfiles,
                _always=True,
            )
            success_r()
        except real_sh.ErrorReturnCode as e:
            error_r()
            header("Exit code: ", nr=True)
            print(e.exit_code)
            if e.stdout:
                header("STDOUT:")
                print(e.stdout.decode())
            if e.stderr:
                header("STDERR:")
                print(e.stderr.decode())
            sys.exit(1)
    else:
        try:
            rev = sh(args, "git", "rev-parse", "HEAD", _cwd=args.dotfiles, _always=True)
        except real_sh.ErrorReturnCode as e:
            rev = None
        if rev:
            info("Updating", args.dotfiles + "... ", nr=True)
            sh(args, "git", "pull", _cwd=args.dotfiles)
            sh(
                args,
                "git",
                "submodule",
                "update",
                "--init",
                "--recursive",
                "--quiet",
                _cwd=args.dotfiles,
            )
            success_r()
        else:
            error(args.dotfiles, "is not a git repository, can't update.")
            sys.exit(1)
    commit = sh(
        args, "git", "rev-parse", "--short", "HEAD", _cwd=args.dotfiles, _always=True
    )
    info("Updating dotfiles successful (commit: {})".format(commit.rstrip()))


@action
def link(args):
    info("Linking dotfiles to", args.prefix, nr=not args.pretend)

    first_fail = True

    dot = lambda f: [".", ""][f.startswith(".")] + f

    # Link top level files
    for f in find(args, args.dotfiles, "f"):
        what = os.path.join(args.dotfiles, f)
        where = os.path.join(args.prefix, dot(f))
        try:
            sh(args, "ln", "-fs", what, where)
        except real_sh.ErrorReturnCode:
            if first_fail:
                first_fail = False
                error_r()
            debug("Error linking", "'" + what + "'", "to", "'" + where + "'", "failed")

    # Create top level directories and symlink anything underneath
    for d in find(args, args.dotfiles, "d"):
        try:
            sh(args, "mkdir", "-p", os.path.join(args.prefix, dot(d)))
            for df in find(args, os.path.join(args.dotfiles, d)):
                what = os.path.join(args.dotfiles, d, df)
                where = os.path.join(args.prefix, dot(d), df)
                sh(args, "ln", "-fs", what, where)
        except real_sh.ErrorReturnCode:
            if first_fail:
                first_fail = False
                error_r()
            debug(
                "Error linking", "'" + os.path.join(args.dotfiles, d) + "'", "or contents"
            )

    if first_fail:
        success_r()


def main():
    actions_dict = {f.__name__: f for f in action.list}
    prefix = os.path.expanduser("~")

    p = argparse.ArgumentParser()
    p.add_argument("-b", "--bland", action="store_true", default=False)
    p.add_argument("-p", "--prefix", type=str, default=prefix)
    p.add_argument("-P", "--pretend", action="store_true", default=False)
    p.add_argument(
        "-d", "--dotfiles", type=str, default=os.path.join(prefix, ".dotfiles"),
    )
    p.add_argument(
        "-g", "--git-url", type=str, default="https://github.com/sysr-q/dotfiles.git",
    )
    p.add_argument("--branch", type=str, default="master")
    p.add_argument(
        "-a", "--actions", nargs="+", choices=actions_dict, default=["update", "link"]
    )

    args = p.parse_args()

    if args.bland:
        # /shrug
        global Prefixes
        Prefixes = PlainPrefixes

    for act in args.actions:
        actions_dict[act](args)


if __name__ == "__main__":
    main()
