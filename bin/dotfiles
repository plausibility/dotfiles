#!/usr/bin/env bash
# script to update dotfiles and everything else
# inspired by https://github.com/cowboy/dotfiles

PRETEND=0
FORCE=0
VERBOSE=0
GIT_URL="git://github.com/sysr-q/dotfiles.git"
ACTIONS="update link copy test"

function usage() {
	cat << EOF
Usage: $1 [-h] [-P] [-F] [-v] [-g <git_url>] [-a <actions>]

Options:
    -h            Show this help
    -P            Enable pretend mode (don't make any changes)
    -F            Force install (if ~/.dotfiles exists, remove it)
    -v            Enable verbose mode (print commands before running them)
    -g <git_url>  Clone the dotfiles repo from git_url if this is a new
                  installation (or if -F is set).
                  Default is "$GIT_URL".
    -a <actions>  Space separated list of actions to perform.
                  Default is "$ACTIONS".
EOF
} # '

# display helpers
function e_header()  { echo -e "\n\033[1m$@\033[0m"; }
function e_success() { echo -e " \033[0;32m✔\033[0m $@"; }
function e_error()   { echo -e " \033[0;31m✖\033[0m $@"; }
function e_arrow()   { echo -e " \033[0;33m➜\033[0m $@"; }

function p_find () {
	if [[ $# -gt 1 ]]; then
		t="-type $2"
	fi
	find "$1" -maxdepth 1 -mindepth 1 $t -print0 | xargs -0 -I{} basename "{}"
}

# Mock things if we're in pretend mode.
function p_call() {
	([[ $PRETEND -eq 1 ]] || [[ $VERBOSE -eq 1 ]]) && e_arrow "$@"
	[[ $PRETEND -eq 1 ]] || "$@"
}

# actions should be functions  with names that start with 'action_'
# actions that should be executed by default should have their names
# (minus 'action_') added to the ACTIONS list at the top of this file

function action_update() {
	if [[ ! -d "$HOME/.dotfiles" ]] || [[ $FORCE -eq 1 ]]; then
		# dotfiles dir doesnt't exist (or we're being forced to recreate it)
		[[ $FORCE -eq 1 ]] && p_call rm -rf "$HOME/.dotfiles"
		e_header "Cloning dotfiles repository..."
		p_call git clone --recursive "$GIT_URL" "$HOME/.dotfiles" 2>/dev/null
	else
		# dotfiles dir exists, check if it's a git repo
		cd "$HOME/.dotfiles"
		if git rev-parse HEAD 2>/dev/null >/dev/null; then
			# it's a git repo
			e_header "Updating ~/.dotfiles..."
			p_call git pull
			p_call git submodule update --init --recursive --quiet 2>/dev/null
		else
			# it's not a git repo
			e_error "~/.dotfiles is not a Git repository, can't update it."
			return 1
		fi
	fi
	cd "$HOME/.dotfiles"
	e_success "Updating dotfiles successful (commit: $(git rev-parse --short HEAD))"
}

function action_link() {
	e_header "Linking..."
	e_arrow "Processing files in $HOME/.dotfiles/link"
	for fn in $(p_find "$HOME/.dotfiles/link/" f); do
		[[ -e "$HOME/$fn" ]] && p_call rm -rf "$HOME/$fn"
		p_call ln -fs "$HOME/.dotfiles/link/$fn" "$HOME/$fn"
		tmp_ret="$?"
		if [[ "$tmp_ret" -ne 0 ]]; then
			e_error "Failed to link \"$fn\": ln exited with $tmp_ret"
			return 1
		fi
	done
	# handle directories
	for dir in $(p_find "$HOME/.dotfiles/link/" d); do
		e_arrow "Processing files in $HOME/.dotfiles/link/$dir"
		p_call mkdir -p "$HOME/$dir"
		for fn in $(p_find "$HOME/.dotfiles/link/$dir"); do
			[[ -e "$HOME/$dir/$fn" ]] && p_call rm -rf "$HOME/$dir/$fn"
			p_call ln -fs "$HOME/.dotfiles/link/$dir/$fn" "$HOME/$dir/$fn"
			tmp_ret="$?"
			if [[ "$tmp_ret" -ne 0 ]]; then
				e_error "Failed to link \"$fn\": ln exited with $tmp_ret"
				return 1
			fi
		done
		# Blank line.
		echo
	done
	e_success "Linking successful!"
}

function action_copy() {
	e_header "Copying files..."
	for fn in $(p_find "$HOME/.dotfiles/copy/"); do
		p_call cp -rf "$HOME/.dotfiles/copy/$fn" "$HOME/$fn"
		tmp_ret="$?"
		if [[ "$tmp_ret" -ne 0 ]]; then
			e_error "Failed to copy \"$fn\": cp exited with $tmp_ret"
			return 1
		fi
	done
	e_success "Copying files successful!"
}

function action_test() {
	e_header "Testing configuration..."

	e_arrow "Testing \$PATH..."
	has_path="$(bash -c "source \"$HOME/.profile\" && if [[ \":$PATH:\" == *\":$HOME/.dotfiles/bin\"* ]]; then echo 1; else echo 0; fi")"
	if [[ "$has_path" == '1' ]]; then
		e_success "\$PATH contains \"~/.dotfiles/bin\""
	else
		e_error "\$PATH does NOT contain \"~/.dotfiles/bin\" :("
	fi

	e_arrow "Testing shell sourcing..."
	bash_source="$(env -i bash -c "source \"$HOME/.bashrc\" && echo \$DOTFILES_SOURCED")"
	if [[ "$bash_source" == '1' ]]; then
		e_success "bash sources \"~/.dotfiles/source\""
	else
		e_error "bash does NOT source \"~/.dotfiles/source\"."
		e_arrow "To fix this, add the following line to your \".bashrc\":"
		e_arrow "source \"\$HOME/.dotfiles/lib/source.sh\""
	fi

	zsh_source="$(env -i zsh -c "source \"$HOME/.zshrc\" && echo \$DOTFILES_SOURCED")"
	if [[ "$zsh_source" == '1' ]]; then
		e_success "zsh sources \"~/.dotfiles/source\""
	else
		e_error "zsh does NOT source \"~/.dotfiles/source\"."
		e_arrow "To fix this, add the following line to your \".zshrc\":"
		e_arrow "source \"\$HOME/.dotfiles/lib/source.sh\""
	fi
}

while getopts "hPFvg:a:" OPTION; do
	case "$OPTION" in
		h)
			usage $(basename $0)
			exit 1
			;;
		P)
			PRETEND=1
			e_arrow "Pretend mode enabled - I won't actually make any changes."
			;;
		F)
			FORCE=1
			;;
		v)
			VERBOSE=1
			;;
		g)
			GIT_URL="$OPTARG"
			;;
		a)
			ACTIONS="$OPTARG"
			;;
	esac
done

# launching the actions in $ACTIONS
for action in $ACTIONS; do
	if declare -f "action_$action" >/dev/null; then
		"action_$action"; tmp_ret="$?"
		if [[ "$tmp_ret" -ne 0 ]] ; then
			# action failed
			e_error "Action \"$action\" returned non-zero error code ($tmp_ret), aborting"
			exit 1
		fi
	else
		e_error "Action \"$action\" could not be executed, aborting"
		exit 1
	fi
done
echo
